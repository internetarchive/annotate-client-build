{
  "version": 3,
  "sources": [
    "node_modules/browser-pack/_prelude.js",
    "src/boot/boot.js",
    "src/boot/index.js",
    "src/boot/url-template.js",
    "src/shared/polyfills/index.js",
    "src/shared/settings.js"
  ],
  "names": [
    "outer",
    "modules",
    "cache",
    "entry",
    "previousRequire",
    "hypothesisRequire",
    "newRequire",
    "name",
    "jumped",
    "currentRequire",
    "err",
    "Error",
    "code",
    "m",
    "exports",
    "call",
    "x",
    "id",
    "i",
    "length",
    "1",
    "require",
    "module",
    "e",
    "t",
    "querySelector",
    "r",
    "polyfillBundles",
    "injectAssets",
    "concat",
    "_toConsumableArray",
    "bootSidebarApp",
    "createElement",
    "rel",
    "href",
    "sidebarAppUrl",
    "type",
    "head",
    "appendChild",
    "n",
    "assetRoot",
    "o",
    "bootHypothesisClient",
    "_polyfills",
    "Array",
    "isArray",
    "_arrayLikeToArray",
    "_arrayWithoutHoles",
    "Symbol",
    "iterator",
    "Object",
    "from",
    "_iterableToArray",
    "prototype",
    "toString",
    "slice",
    "constructor",
    "test",
    "_unsupportedIterableToArray",
    "TypeError",
    "_nonIterableSpread",
    "forEach",
    "manifest",
    "match",
    "injectStylesheet",
    "src",
    "async",
    "injectScript",
    "requiredPolyfillSets",
    "map",
    "_settings",
    "_boot",
    "_interopRequireDefault",
    "_urlTemplate",
    "__esModule",
    "default",
    "settings",
    "jsonConfigsFrom",
    "document",
    "script",
    "currentScript",
    "scriptUrl",
    "URL",
    "pathname",
    "endsWith",
    "__MANIFEST__",
    "extractOrigin",
    "protocol",
    "hostname",
    "currentScriptOrigin",
    "arguments",
    "querySelectorAll",
    "defineProperty",
    "value",
    "indexOf",
    "replace",
    "hasMethods",
    "every",
    "filter",
    "needsPolyfill",
    "es2015",
    "Promise",
    "Map",
    "Set",
    "String",
    "_toArray",
    "apply",
    "es2016",
    "es2017",
    "es2018",
    "window",
    "url",
    "document.evaluate",
    "evaluate",
    "string.prototype.normalize",
    "fetch",
    "assign",
    "s",
    "hasOwnProperty",
    "JSON",
    "parse",
    "textContent",
    "console",
    "warn"
  ],
  "mappings": "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",
  "sourcesContent": [
    "\n// modules are defined as an array\n// [ module function, map of requireuires ]\n//\n// map of requireuires is short require name -> numeric require\n//\n// anything defined in a previous bundle is accessed via the\n// orig method which is the requireuire for previous bundles\n\n(function() {\n\nfunction outer(modules, cache, entry) {\n    // Save the require from previous bundle to this closure if any\n    var previousRequire = typeof hypothesisRequire == \"function\" && hypothesisRequire;;\n\n    function newRequire(name, jumped){\n        if(!cache[name]) {\n            if(!modules[name]) {\n                // if we cannot find the module within our internal map or\n                // cache jump to the current global require ie. the last bundle\n                // that was added to the page.\n                var currentRequire = typeof hypothesisRequire == \"function\" && hypothesisRequire;;\n                if (!jumped && currentRequire) return currentRequire(name, true);\n\n                // If there are other bundles on this page the require from the\n                // previous one is saved to 'previousRequire'. Repeat this as\n                // many times as there are bundles until the module is found or\n                // we exhaust the require chain.\n                if (previousRequire) return previousRequire(name, true);\n                var err = new Error('Cannot find module \\'' + name + '\\'');\n                err.code = 'MODULE_NOT_FOUND';\n                throw err;\n            }\n            var m = cache[name] = {exports:{}};\n            modules[name][0].call(m.exports, function(x){\n                var id = modules[name][1][x];\n                return newRequire(id ? id : x);\n            },m,m.exports,outer,modules,cache,entry);\n        }\n        return cache[name].exports;\n    }\n    for(var i=0;i<entry.length;i++) newRequire(entry[i]);\n\n    // Override the current require with this new one\n    return newRequire;\n}\n\nreturn outer;\n\n})()\n",
    "import { requiredPolyfillSets } from '../shared/polyfills';\n\n/**\n * @typedef Config\n * @prop {string} assetRoot - The root URL to which URLs in `manifest` are relative\n * @prop {string} sidebarAppUrl - The URL of the sidebar's HTML page\n * @prop {Object.<string,string>} manifest -\n *   A mapping from canonical asset path to cache-busted asset path\n */\n\n/**\n * @param {Document} doc\n * @param {string} href\n */\nfunction injectStylesheet(doc, href) {\n  const link = doc.createElement('link');\n  link.rel = 'stylesheet';\n  link.type = 'text/css';\n  link.href = href;\n  doc.head.appendChild(link);\n}\n\n/**\n * @param {Document} doc\n * @param {string} src - The script URL\n */\nfunction injectScript(doc, src) {\n  const script = doc.createElement('script');\n  script.type = 'text/javascript';\n  script.src = src;\n\n  // Set 'async' to false to maintain execution order of scripts.\n  // See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script\n  script.async = false;\n  doc.head.appendChild(script);\n}\n\n/**\n * @param {Document} doc\n * @param {Config} config\n * @param {string[]} assets\n */\nfunction injectAssets(doc, config, assets) {\n  assets.forEach(function (path) {\n    const url = config.assetRoot + config.manifest[path];\n    if (url.match(/\\.css/)) {\n      injectStylesheet(doc, url);\n    } else {\n      injectScript(doc, url);\n    }\n  });\n}\n\nfunction polyfillBundles(needed) {\n  return requiredPolyfillSets(needed).map(\n    set => `scripts/polyfills-${set}.bundle.js`\n  );\n}\n\n/**\n * Bootstrap the Hypothesis client.\n *\n * This triggers loading of the necessary resources for the client\n *\n * @param {Document} doc\n * @param {Config} config\n */\nfunction bootHypothesisClient(doc, config) {\n  // Detect presence of Hypothesis in the page\n  const appLinkEl = doc.querySelector(\n    'link[type=\"application/annotator+html\"]'\n  );\n  if (appLinkEl) {\n    return;\n  }\n\n  // Register the URL of the sidebar app which the Hypothesis client should load.\n  // The <link> tag is also used by browser extensions etc. to detect the\n  // presence of the Hypothesis client on the page.\n  const sidebarUrl = doc.createElement('link');\n  sidebarUrl.rel = 'sidebar';\n  sidebarUrl.href = config.sidebarAppUrl;\n  sidebarUrl.type = 'application/annotator+html';\n  doc.head.appendChild(sidebarUrl);\n\n  // Register the URL of the annotation client which is currently being used to drive\n  // annotation interactions.\n  const clientUrl = doc.createElement('link');\n  clientUrl.rel = 'hypothesis-client';\n  clientUrl.href = config.assetRoot + 'boot.js';\n  clientUrl.type = 'application/annotator+javascript';\n  doc.head.appendChild(clientUrl);\n\n  const polyfills = polyfillBundles([\n    'document.evaluate',\n    'es2015',\n    'es2016',\n    'es2017',\n    'es2018',\n    'url',\n  ]);\n\n  injectAssets(doc, config, [\n    // Vendor code and polyfills\n    ...polyfills,\n    'scripts/jquery.bundle.js',\n\n    // Main entry point for the client\n    'scripts/annotator.bundle.js',\n\n    'styles/annotator.css',\n    'styles/pdfjs-overrides.css',\n  ]);\n}\n\n/**\n * Bootstrap the sidebar application which displays annotations.\n *\n * @param {Document} doc\n * @param {Config} config\n */\nfunction bootSidebarApp(doc, config) {\n  const polyfills = polyfillBundles([\n    // JS polyfills.\n    'es2015',\n    'es2016',\n    'es2017',\n    'string.prototype.normalize',\n\n    // DOM polyfills. These are loaded after the JS polyfills as they may\n    // depend upon them, eg. for Promises.\n    'fetch',\n    'url',\n  ]);\n\n  injectAssets(doc, config, [\n    ...polyfills,\n\n    // Vendor code required by sidebar.bundle.js\n    'scripts/sentry.bundle.js',\n    'scripts/katex.bundle.js',\n    'scripts/showdown.bundle.js',\n\n    // The sidebar app\n    'scripts/sidebar.bundle.js',\n\n    'styles/katex.min.css',\n    'styles/sidebar.css',\n  ]);\n}\n\n/**\n * Initialize the \"sidebar\" application if run in the sidebar's stub HTML\n * page or the \"annotator\" application otherwise.\n *\n * @param {Document} document_\n * @param {Config} config\n */\nexport default function boot(document_, config) {\n  if (document_.querySelector('hypothesis-app')) {\n    bootSidebarApp(document_, config);\n  } else {\n    bootHypothesisClient(document_, config);\n  }\n}\n",
    "// This is the main entry point for the Hypothesis client in the host page\n// and the sidebar application.\n//\n// The same boot script is used for both entry points so that the browser\n// already has it cached when it encounters the reference in the sidebar\n// application.\n\n// Variables replaced by the build script\n\n/* global __MANIFEST__ */\n\n/**\n * Subset of configuration settings (see https://h.readthedocs.io/projects/client/en/latest/publishers/config/)\n * which affect where the client loads its assets from.\n *\n * @typedef BootSettings\n * @prop {string} [assetRoot]\n * @prop {string} [sidebarAppUrl]\n */\n\nimport { jsonConfigsFrom } from '../shared/settings';\n\nimport boot from './boot';\nimport processUrlTemplate from './url-template';\n\n/** @type {BootSettings} */\nconst settings = jsonConfigsFrom(document);\n\n// Use the asset root and sidebar app locations specified in the host page,\n// if present. This is used by the Hypothesis browser extensions to make the\n// boot script load assets bundled with the extension.\nlet assetRoot;\nif (settings.assetRoot) {\n  // The `assetRoot` setting is assumed to point at the root of the contents of\n  // the npm package.\n  assetRoot = settings.assetRoot + 'build/';\n}\nlet sidebarAppUrl = settings.sidebarAppUrl;\n\n// Otherwise, try to determine the default root URL for assets and the sidebar\n// application from the location where the boot script is hosted.\ntry {\n  const script = /** @type {HTMLScriptElement} */ (document.currentScript);\n  let scriptUrl = new URL(script.src);\n\n  // We only use the bundled sidebar HTML and assets if the boot script has\n  // its original name. If the `<script>` tag references a custom name\n  // (eg. as in \"https://hypothes.is/embed.js\") then we skip this and fall\n  // back to the URLs embedded in the boot script.\n  if (scriptUrl.pathname.endsWith('/boot.js')) {\n    assetRoot = assetRoot || new URL('./', scriptUrl).href;\n    sidebarAppUrl = sidebarAppUrl || new URL('app.html', scriptUrl).href;\n  }\n} catch (e) {\n  // IE does not support `document.currentScript` or the URL constructor.\n}\n\n// Otherwise, fall back to hardcoded default URLs.\nassetRoot = processUrlTemplate(assetRoot || '__ASSET_ROOT__');\nsidebarAppUrl = processUrlTemplate(sidebarAppUrl || '__SIDEBAR_APP_URL__');\n\nboot(document, {\n  assetRoot,\n  // @ts-ignore - `__MANIFEST__` is injected by the build script\n  manifest: __MANIFEST__,\n  sidebarAppUrl,\n});\n",
    "/**\n * Extract the protocol and hostname (ie. host without port) from the URL.\n *\n * We don't use the URL constructor here because IE and early versions of Edge\n * do not support it and this code runs early in the life of the app before any\n * polyfills can be loaded.\n */\nfunction extractOrigin(url) {\n  const match = url.match(/(https?):\\/\\/([^:/]+)/);\n  if (!match) {\n    return null;\n  }\n  return { protocol: match[1], hostname: match[2] };\n}\n\nfunction currentScriptOrigin(document_ = document) {\n  try {\n    let scriptEl = /** @type {HTMLScriptElement} */ (document_.currentScript);\n\n    if (!scriptEl) {\n      // Fallback for IE 11.\n      const scripts = document_.querySelectorAll('script');\n      scriptEl = scripts[scripts.length - 1];\n    }\n\n    return extractOrigin(scriptEl.src);\n  } catch (err) {\n    return null;\n  }\n}\n\n/**\n * Replace references to `current_host` and `current_scheme` URL template\n * parameters with the corresponding elements of the current script URL.\n *\n * During local development, there are cases when the client/h needs to be accessed\n * from a device or VM that is not the system where the development server is\n * running. In that case, all references to `localhost` need to be replaced\n * with the IP/hostname of the dev server.\n *\n * @param {string} url\n * @param {Document} document_\n */\nexport default function processUrlTemplate(url, document_ = document) {\n  if (url.indexOf('{') === -1) {\n    // Not a template. This should always be the case in production.\n    return url;\n  }\n\n  const origin = currentScriptOrigin(document_);\n\n  if (origin) {\n    url = url.replace('{current_host}', origin.hostname);\n    url = url.replace('{current_scheme}', origin.protocol);\n  }\n\n  return url;\n}\n",
    "/**\n * Checkers to test which polyfills are required by the current browser.\n *\n * This module executes in an environment without any polyfills loaded so it\n * needs to run in old browsers, down to IE 11.\n *\n * See gulpfile.js for details of how to add a new polyfill.\n */\n\n/**\n * Return true if `obj` has all of the methods in `methods`.\n */\nfunction hasMethods(obj, ...methods) {\n  return methods.every(method => typeof obj[method] === 'function');\n}\n\n/**\n * Map of polyfill set name to function to test whether the current browser\n * needs that polyfill set.\n *\n * Each checker function returns `true` if the polyfill is required or `false`\n * if the browser has the functionality natively available.\n */\nconst needsPolyfill = {\n  es2015: () => {\n    // Check for new objects in ES2015.\n    if (\n      typeof Promise !== 'function' ||\n      typeof Map !== 'function' ||\n      typeof Set !== 'function' ||\n      typeof Symbol !== 'function'\n    ) {\n      return true;\n    }\n\n    // Check for new methods on existing objects in ES2015.\n    const objMethods = [\n      [Array, 'from'],\n      [Array.prototype, 'fill', 'find', 'findIndex'],\n      [Object, 'assign'],\n      [String.prototype, 'startsWith', 'endsWith'],\n    ];\n    for (let [obj, ...methods] of objMethods) {\n      if (!hasMethods(obj, ...methods)) {\n        return true;\n      }\n    }\n\n    return false;\n  },\n\n  es2016: () => {\n    return !hasMethods(Array.prototype, 'includes');\n  },\n\n  es2017: () => {\n    return !hasMethods(Object, 'entries', 'values');\n  },\n\n  es2018: () => {\n    if (!window.Promise) {\n      // IE11 does not have a Promise object.\n      return true;\n    }\n    return !hasMethods(Promise.prototype, 'finally');\n  },\n\n  // Test for a fully-working URL constructor.\n  url: () => {\n    try {\n      // Some browsers do not have a URL constructor at all.\n      const url = new window.URL('https://hypothes.is');\n\n      // Other browsers have a broken URL constructor.\n      if (url.hostname !== 'hypothes.is') {\n        throw new Error('Broken URL constructor');\n      }\n      return false;\n    } catch (e) {\n      return true;\n    }\n  },\n\n  // Test for XPath evaluation.\n  'document.evaluate': () => {\n    // Depending on the browser the `evaluate` property may be on the prototype\n    // or just the object itself.\n    return typeof document.evaluate !== 'function';\n  },\n\n  // Test for Unicode normalization. This depends on a large polyfill so it\n  // is separated out into its own bundle.\n  'string.prototype.normalize': () => {\n    return !hasMethods(String.prototype, 'normalize');\n  },\n\n  fetch: () => {\n    return typeof window.fetch !== 'function';\n  },\n};\n\n/**\n * Return the subset of polyfill sets from `needed`  which are needed by the\n * current browser.\n */\nexport function requiredPolyfillSets(needed) {\n  return needed.filter(set => {\n    const checker = needsPolyfill[set];\n    if (!checker) {\n      throw new Error(`Unknown polyfill set \"${set}\"`);\n    }\n    return checker();\n  });\n}\n",
    "// `Object.assign()`-like helper. Used because this script needs to work\n// in IE 10/11 without polyfills.\nfunction assign(dest, src) {\n  for (const k in src) {\n    if (src.hasOwnProperty(k)) {\n      dest[k] = src[k];\n    }\n  }\n  return dest;\n}\n\n/**\n * Return a parsed `js-hypothesis-config` object from the document, or `{}`.\n *\n * Find all `<script class=\"js-hypothesis-config\">` tags in the given document,\n * parse them as JSON, and return the parsed object.\n *\n * If there are no `js-hypothesis-config` tags in the document then return\n * `{}`.\n *\n * If there are multiple `js-hypothesis-config` tags in the document then merge\n * them into a single returned object (when multiple scripts contain the same\n * setting names, scripts further down in the document override those further\n * up).\n *\n * @param {Document|Element} document - The root element to search.\n */\nexport function jsonConfigsFrom(document) {\n  const config = {};\n  const settingsElements = document.querySelectorAll(\n    'script.js-hypothesis-config'\n  );\n\n  for (let i = 0; i < settingsElements.length; i++) {\n    let settings;\n    try {\n      settings = JSON.parse(settingsElements[i].textContent || '');\n    } catch (err) {\n      console.warn(\n        'Could not parse settings from js-hypothesis-config tags',\n        err\n      );\n      settings = {};\n    }\n    assign(config, settings);\n  }\n\n  return config;\n}\n"
  ],
  "sourceRoot": ""
}